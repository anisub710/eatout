# Exercise 2: More ggplot2 Grammar
# Install and load `ggplot2`
# install.packages("ggplot2") # if needed
library('ggplot2')
library('dplyr')
# For this exercise you will again be working with the `diamonds` data set.
# Use `?diamonds` to review details about this data set
## Statistical Transformations
# Draw a bar chart of the diamonds data, organized by cut
# The height of each bar is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds, mapping = aes(x = cut)) +
geom_bar()
# Use the `stat_count` to apply the statistical transformation "count" to the diamonds
# by cut. You do not need a separate geometry layer!
ggplot(data = diamonds, mapping = aes(x = cut)) +
stat_count()
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median` as the function y
ggplot(data = diamonds, mapping = aes(x = cut, y = depth)) +
stat_summary(fun.ymin = min, fun.ymax = max, fun.y = median)
## Position Adjustments
# Draw a bar chart of diamond data organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
# Draw the same chart again, but with each element positioned to "fill" the y axis
# Draw the same chart again, but with each element positioned to "dodge" each other
# Draw a plot with point geometry with the x-position mapped to `cut` and the y-position mapped to `clarity`
# This creates a "grid" grouping the points
# Use the "jitter" position adjustment to keep the points from all overlapping!
# (This works a little better with a sample of diamond data, such as from the previous exercise).
## Scales
# Draw a "boxplot" (with `geom_boxplot()`) for the diamond's price (y) by color (x)
# This has a lot of outliers, making it harder to read. To fix this, draw the same plot but
# with a _logarithmic_ scale for the y axis.
# For another version, draw the same plot but with `violin` geometry instead of `boxplot` geometry!
# How does the logarithmic scale change the data presentation?
# Another interesting plot: draw a plot of the diamonds price (y) by carat (x), using a heatmap of 2d bins
# (geom_bin2d)
# What happens when you make the x and y channels scale logarithmically?
# Draw a scatter plot for the diamonds  price (y) by carat (x). Color each point by the clarity
# (Remember, this will take a while. Use a sample of the diamonds for faster results)
# Change the color of the previous plot using a ColorBrewer scale of your choice. What looks nice?
## Coordinate Systems
# Draw a bar chart with x-position and fill color BOTH mapped to cut
# For best results, SET the `width` of the geometry to be 1 (fill plot, no space between)
# You can save this to a variable for easier modifications
# Draw the same chart, but with the coordinate system flipped
# Draw the same chart, but in a polar coordinate system. Now you have a Coxcomb chart!
## Facets
# Take the scatter plot of price by carat data (colored by clarity) and add _facets_ based on
# the diamond's `color`
## Saving Plots
# Use the `ggsave()` function to save one of your plots (the most recent one generated) to disk.
# Name the output file "my-plot.png".
# Make sure you've set the working directory!!
ggplot(data = diamonds, mapping = aes(x = cut, y = depth)) +
stat_summary(fun.ymin = min, fun.ymax = max, fun.y = median)
# Exercise 3: Mapping with ggplot2
# Install and load `ggplot2` and `dplyr`
library("ggplot2")
library("dplyr")
# Read in the election data file (.csv)
# BE SURE TO SET YOUR WORKING DIRECTORY!
election <- read.csv('data/2016_US_County_Level_Presidential_Results.csv', stringsAsFactors = FALSE)
# Inspect the `election` data frame to understand the data you're working with
# Consider: what column contains state names? What column contains county names?
# What format are those county names in?
# Use `map_data()` to load the `county` map of the US, storing it in a variable
# Inspect this data frame to understand what data yu're working with
# Consider: what column contains state names? What column contains county names?
# What format are those county names in?
### Data Wrangling
# The format for the states and and counties are different, so we need some way to match them
# The `election` data does have FIPS codes (https://en.wikipedia.org/wiki/FIPS_county_code)
# which we can use to match. A data frame that links FIPS to the state and county names is
# available from the `maps` library (which you should install and load)
# Use `data()` to load the `"county.fips"` data frame into the environment (does not return anything)
# Inspect the `county.fips` data frame to see what you got
# Use a `join` operation to add the `fips` column to your `counties` data frame.
# Note that you may need to use `paste0()` and `mutate() to make a column of "state,county"
# to join by!
# Note: don't worry about Alaska for this exercise.
# Now you can join the `counties` map data (with fips!) to the `election` data
# Hint: use `by = c("fips" = "combined_fips")` to specify the column to join by
# One more change: add a column to store whether the Democrat or the Republication party
# had the higher number of votes ("won" the county)
# Hint: start by adding a column of logical values (TRUE/FALSE) of whether a party one,
#       and then join that with a simple data frame that matches to Strings
### Data Visualization
# Finally, plot the polygons of the map!
# Be sure and specify the `x` (longitude), `y` (latitude), and `group` (group) asthetics
# Use the `coord_quick_map()` coordinate system to make it look nice
# Modify the above plot so that each geometry is filled based on which party won the county
# Specify a `manual` fill scale to make Democratic counties "blue" and Republican counties "red"
# For fun: how else can you fill in this map? What other insights can you produce?
ggplot(data = usa.states) +
geom_polygon(aes(x = long, y = lat, group = group)) +
coord_quickmap()  # map coordinate system!
################
### GG PLOT2 ###
################
#install.packages("ggplot2")
library("ggplot2")
View(mpg)
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class), size = 1) +
geom_point() +
geom_smooth(se = FALSE)
ggplot(data = mpg) +
geom_bar(mapping = aes(x = class, color = class), size = 1)
shiny::runApp('Downloads')
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
View(iris.metrics)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
iris[sample(nrow(iris), input$sampleSize),]
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
a
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset <- reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
runApp()
runApp()
runApp()
runApp()
