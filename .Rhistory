<<<<<<< HEAD
# Exercise 2: More ggplot2 Grammar
# Install and load `ggplot2`
# install.packages("ggplot2") # if needed
library('ggplot2')
library('dplyr')
# For this exercise you will again be working with the `diamonds` data set.
# Use `?diamonds` to review details about this data set
## Statistical Transformations
# Draw a bar chart of the diamonds data, organized by cut
# The height of each bar is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds, mapping = aes(x = cut)) +
geom_bar()
# Use the `stat_count` to apply the statistical transformation "count" to the diamonds
# by cut. You do not need a separate geometry layer!
ggplot(data = diamonds, mapping = aes(x = cut)) +
stat_count()
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median` as the function y
ggplot(data = diamonds, mapping = aes(x = cut, y = depth)) +
stat_summary(fun.ymin = min, fun.ymax = max, fun.y = median)
## Position Adjustments
# Draw a bar chart of diamond data organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
# Draw the same chart again, but with each element positioned to "fill" the y axis
# Draw the same chart again, but with each element positioned to "dodge" each other
# Draw a plot with point geometry with the x-position mapped to `cut` and the y-position mapped to `clarity`
# This creates a "grid" grouping the points
# Use the "jitter" position adjustment to keep the points from all overlapping!
# (This works a little better with a sample of diamond data, such as from the previous exercise).
## Scales
# Draw a "boxplot" (with `geom_boxplot()`) for the diamond's price (y) by color (x)
# This has a lot of outliers, making it harder to read. To fix this, draw the same plot but
# with a _logarithmic_ scale for the y axis.
# For another version, draw the same plot but with `violin` geometry instead of `boxplot` geometry!
# How does the logarithmic scale change the data presentation?
# Another interesting plot: draw a plot of the diamonds price (y) by carat (x), using a heatmap of 2d bins
# (geom_bin2d)
# What happens when you make the x and y channels scale logarithmically?
# Draw a scatter plot for the diamonds  price (y) by carat (x). Color each point by the clarity
# (Remember, this will take a while. Use a sample of the diamonds for faster results)
# Change the color of the previous plot using a ColorBrewer scale of your choice. What looks nice?
## Coordinate Systems
# Draw a bar chart with x-position and fill color BOTH mapped to cut
# For best results, SET the `width` of the geometry to be 1 (fill plot, no space between)
# You can save this to a variable for easier modifications
# Draw the same chart, but with the coordinate system flipped
# Draw the same chart, but in a polar coordinate system. Now you have a Coxcomb chart!
## Facets
# Take the scatter plot of price by carat data (colored by clarity) and add _facets_ based on
# the diamond's `color`
## Saving Plots
# Use the `ggsave()` function to save one of your plots (the most recent one generated) to disk.
# Name the output file "my-plot.png".
# Make sure you've set the working directory!!
ggplot(data = diamonds, mapping = aes(x = cut, y = depth)) +
stat_summary(fun.ymin = min, fun.ymax = max, fun.y = median)
# Exercise 3: Mapping with ggplot2
# Install and load `ggplot2` and `dplyr`
library("ggplot2")
library("dplyr")
# Read in the election data file (.csv)
# BE SURE TO SET YOUR WORKING DIRECTORY!
election <- read.csv('data/2016_US_County_Level_Presidential_Results.csv', stringsAsFactors = FALSE)
# Inspect the `election` data frame to understand the data you're working with
# Consider: what column contains state names? What column contains county names?
# What format are those county names in?
# Use `map_data()` to load the `county` map of the US, storing it in a variable
# Inspect this data frame to understand what data yu're working with
# Consider: what column contains state names? What column contains county names?
# What format are those county names in?
### Data Wrangling
# The format for the states and and counties are different, so we need some way to match them
# The `election` data does have FIPS codes (https://en.wikipedia.org/wiki/FIPS_county_code)
# which we can use to match. A data frame that links FIPS to the state and county names is
# available from the `maps` library (which you should install and load)
# Use `data()` to load the `"county.fips"` data frame into the environment (does not return anything)
# Inspect the `county.fips` data frame to see what you got
# Use a `join` operation to add the `fips` column to your `counties` data frame.
# Note that you may need to use `paste0()` and `mutate() to make a column of "state,county"
# to join by!
# Note: don't worry about Alaska for this exercise.
# Now you can join the `counties` map data (with fips!) to the `election` data
# Hint: use `by = c("fips" = "combined_fips")` to specify the column to join by
# One more change: add a column to store whether the Democrat or the Republication party
# had the higher number of votes ("won" the county)
# Hint: start by adding a column of logical values (TRUE/FALSE) of whether a party one,
#       and then join that with a simple data frame that matches to Strings
### Data Visualization
# Finally, plot the polygons of the map!
# Be sure and specify the `x` (longitude), `y` (latitude), and `group` (group) asthetics
# Use the `coord_quick_map()` coordinate system to make it look nice
# Modify the above plot so that each geometry is filled based on which party won the county
# Specify a `manual` fill scale to make Democratic counties "blue" and Republican counties "red"
# For fun: how else can you fill in this map? What other insights can you produce?
ggplot(data = usa.states) +
geom_polygon(aes(x = long, y = lat, group = group)) +
coord_quickmap()  # map coordinate system!
################
### GG PLOT2 ###
################
#install.packages("ggplot2")
library("ggplot2")
View(mpg)
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class), size = 1) +
geom_point() +
geom_smooth(se = FALSE)
ggplot(data = mpg) +
geom_bar(mapping = aes(x = class, color = class), size = 1)
shiny::runApp('Downloads')
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
View(iris.metrics)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
iris[sample(nrow(iris), input$sampleSize),]
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
a
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset = reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
# install.packages(c('ggplot2', 'shiny'))
library(rsconnect)
library(shiny)
library(ggplot2)
library(plotly)
# Create a `reactiveValues()` variable
iris.data <- iris
iris.metrics <- iris.data %>%
select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
#View(iris.metrics)
# Define a UI using a fluidPage layout
my.ui <- fluidPage(
# declare the page titlePanel to be "Anderson's Iris Data Set Visualization"
titlePanel("Anderson's Iris Data Set Visualization"),
# Include a `sidebarLayout()`
sidebarLayout(
# The `siderbarPanel()` should have the following control widgets:
sidebarPanel(
# selects all
checkboxGroupInput("checkGroup",
label = h3("Which Species?"),
choices = c("Setosa" = "setosa",
"Versicolor" = "versicolor", "Virginica" = "virginica"),
selected = c("setosa", "versicolor", "virginica"), inline = TRUE),
# A sliderInput labeled "Price (in dollars)". This slider should let the user pick a range
# between the minimum and maximum price of the entire diamond data set
sliderInput('sampleSize', 'Sample Size?', min = 25, max = 150,
value = 100, step = 5),
selectInput("selectX", label = h3("Select x-axis"),
choices = names(iris.metrics)),
selectInput("selectY", label = h3("Select y-axis"),
choices = names(iris.metrics), names(iris.metrics)[[2]]),
numericInput("plotSize", label = h3("Size of Plots"), min = 0.5, max = 4, step = 0.5, value = 1.5),
# A checkboxInput labeled "Show Trendline". It's default value should be TRUE
checkboxInput('bestFit', label=strong("Show Line of Best Fit"), value=TRUE)
),
# The `mainPanel()` should have the following reactive outputs:
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plot", plotlyOutput("plot")),
tabPanel("Table", dataTableOutput("table")))
# A plotOutput showing a plot based on the user specifications
)
)
)
# Define a Server function for the app
my.server <- function(input, output) {
dataset <- reactive({
iris[iris$Species%in%input$checkGroup,]
iris[sample(nrow(iris), input$sampleSize),]
})
output$plot <- renderPlotly({
p <- ggplot(iris.data %>% filter(Species %in% input$checkGroup), aes_string(x = input$selectX, y = input$selectY,
group = c("Species"),
color = c("Species"))) + geom_point(size = input$plotSize)
if(input$bestFit) {
p <- p + geom_smooth(se = TRUE, size = input$plotSize)
}
return(ggplotly(p))
})
output$table <- renderDataTable({
return(dataset())
})
}
shinyServer(server)
shinyApp(ui = my.ui, server = my.server)
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
shiny::runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
runApp('Desktop/INFO 210/final_project_demo')
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
setwd("~/Desktop/INFO 210/final_project_demo")
runApp()
=======
header <- HEAD("https://api.yelp.com/v3", config(token = parsed_creds)
first.response <- GET("https://api.yelp.com/v3/businesses/search?term=delis&latitude=37.786882&longitude=-122.399972",
query = first.query)
first.response
first.body <- fromJSON(content(first.response, "text"))
first.body
?config
header <- HEAD("https://api.yelp.com/v3", config(token = parsed_creds))
header <- HEAD("https://api.yelp.com/v3", config(token = parsed_creds$path))
test <-  parsed_creds$path
header <- HEAD("https://api.yelp.com/v3", config(token = test))
shiny::runApp('Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2')
runApp('Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2')
setwd("~/Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2")
runApp()
runApp()
install.packages('rsconnect')
rsconnect::setAccountInfo(name='ask710', token='98FFB80B66CB8E017B1238789C45855B', secret='h2bxtkkzQYSjgXZ0CbyNSnURR5sbKTaXBeaeuxmH')
rsconnect::deployApp('/Users/anirudhsubramanyam/Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2/app.R')
install.packages('rsconnect')
rsconnect::setAccountInfo(name='ask710', token='98FFB80B66CB8E017B1238789C45855B', secret='h2bxtkkzQYSjgXZ0CbyNSnURR5sbKTaXBeaeuxmH')
library(rsconnect)
rsconnect::deployApp('/Users/anirudhsubramanyam/Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2/')
install.packages("rsconnect")
library(rsconnect)
rsconnect::setAccountInfo(name='ask710', token='98FFB80B66CB8E017B1238789C45855B', secret='h2bxtkkzQYSjgXZ0CbyNSnURR5sbKTaXBeaeuxmH')
rsconnect::deployApp('/Users/anirudhsubramanyam/Desktop/UW/Quarter 2/INFO 201/Practice/module15-shiny/exercise-2/')
library(leaflet)
library(shiny)
library(httr)
library(jsonlite)
library(dplyr)
library(maps)
library(ggplot2)
state.data <- map_data("state")
colnames(state.data)<- c("lng", "lat", "group", "order", "state", "subregion")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
setwd("~/Desktop/UW/Quarter 2/INFO 201/Practice/final_project_demo")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
colnames(restaurant.ratings) <- c("ratings", "county", "state")
restaurant.ratings <- restaurant.ratings %>% group_by(state) %>% summarise(ratings = mean(ratings))
restaurant.ratings$state <- tolower(restaurant.ratings$state)
restaurant.data <- left_join(state.data, restaurant.ratings)
restaurant.data <- restaurant.data %>% select(lng, lat, state, ratings)
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(lng = ~lng, lat = ~lat)
map.test
library(leaflet)
library(shiny)
library(httr)
library(jsonlite)
library(dplyr)
library(maps)
library(ggplot2)
data(state.map)
install.packages("choroplethrMaps")
library(choroplethrMaps)
data(state.map)
View(state.map)
state.data2 <- data(state.map)
state.data2 <- state.data2 %>% select(lng = long, lat, state = region)
state.data2 <- state.data2 %>% select(long, lat,region)
state.data2 <- data(state.map)
state.data2 <- state.data2 %>% select(long, lat,region)
state.data2 <- data(state.map)
View(state.data2)
state.data2 <- state.map
state.data2 <- state.data2 %>% select(long, lat,region)
state.data2 <- state.data2 %>% select(lng = long, lat,region)
state.data2 <- state.data2 %>% select(lng = long, lat,state = region)
state.data2 <- state.map
state.data2 <- state.data2 %>% select(lng = long, lat,state = region)
View(state.data2)
restaurant.ratings <- restaurant.ratings %>% group_by(state) %>% summarise(ratings = mean(ratings))
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
colnames(restaurant.ratings) <- c("ratings", "county", "state")
restaurant.ratings <- restaurant.ratings %>% group_by(state) %>% summarise(ratings = mean(ratings))
restaurant.ratings$state <- tolower(restaurant.ratings$state)
restaurant.data <- left_join(state.data2, restaurant.ratings)
restaurant.data <- restaurant.data %>% select(lng, lat, state, ratings)
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(lng = ~lng, lat = ~lat)
map.test
state.data <- map_data("state")
colnames(state.data)<- c("lng", "lat", "group", "order", "state", "subregion")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
colnames(restaurant.ratings) <- c("ratings", "county", "state")
restaurant.ratings <- restaurant.ratings %>% group_by(state) %>% summarise(ratings = mean(ratings))
restaurant.ratings$state <- tolower(restaurant.ratings$state)
restaurant.data <- left_join(state.data, restaurant.ratings)
restaurant.data <- restaurant.data %>% select(lng, lat, state, ratings)
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(lng = ~lng, lat = ~lat)
map.test
length(mapStates$x)
mapStates = map("state", fill = TRUE, plot = FALSE)
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(data = mapStates)
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(data = mapStates, fillColor = ~restaurant.data$ratings)
map.test
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(data = mapStates, fillColor = ~pal(restaurant.data$ratings))
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(data = mapStates, fillColor = ~pal(restaurant.data$ratings))
map.test
length(mapStates$x)
length(mapStates$y)
df <- data.frame(matrix(unlist(mapStates), nrow=15599, byrow=T), stringsAsFactors = FALSE)
View(df)
install.packages("geojsonio")
library(geojsonio)
states <- geojsonio::geojson_read("json/us-states.geojson", what = "sp")
states <- geojsonio::geojson_read("json/us-states.json", what = "sp")
map.test <- leaflet(states) %>%
addTiles()%>%
addPolygons()
map.test
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
map.test <- leaflet(states) %>%
addTiles()%>%
addPolygons(fillColor = ~restaurant.data$ratings)
map.test
names(states)
View(states)
View(states)
restaurant.ratings <- restaurant.ratings %>% group_by(NAME) %>% summarise(ratings = mean(ratings))
colnames(restaurant.ratings) <- c("ratings", "county", "NAME")
library(geojsonio)
library(leaflet)
library(shiny)
library(httr)
library(jsonlite)
library(dplyr)
library(maps)
library(ggplot2)
library(geojsonio)
states <- geojsonio::geojson_read("json/us-states.json", what = "sp")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
colnames(restaurant.ratings) <- c("ratings", "county", "NAME")
restaurant.ratings <- restaurant.ratings %>% group_by(NAME) %>% summarise(ratings = mean(ratings))
restaurant.ratings[12, 1] <- "Hawaii"
restaurant.data <- left_join(states, restaurant.ratings)
library(sp)
restaurant.data <- merge(states, restaurant.ratings)
View(restaurant.ratings)
View(restaurant.data)
View(restaurant.ratings)
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons()
map.test
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings))
map.test
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(fillColor = ~ratings)
map.test
names(restaurant.data)
restaurant.data <- na.omit(restaurant.data)
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
map.test <- leaflet(restaurant.data) %>%
addTiles()%>%
addPolygons(fillColor = ~ratings)
map.test
library(leaflet)
library(shiny)
library(httr)
library(jsonlite)
library(dplyr)
library(geojsonio)
library(sp)
states <- geojsonio::geojson_read("json/us-states.json", what = "sp")
source("accessToken.R")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
colnames(restaurant.ratings) <- c("ratings", "county", "NAME")
restaurant.ratings <- restaurant.ratings %>% group_by(NAME) %>% summarise(ratings = mean(ratings))
restaurant.ratings[12, 1] <- "Hawaii"
restaurant.data <- merge(states, restaurant.ratings)
restaurant.data <- na.omit(restaurant.data)
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
pal <- colorBin(
palette = "YlOrRd",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
map.test <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7)
map.test
map.test <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
restaurant.data$NAME
labels <- sprintf(
"<strong>%s</strong><br/>%g people / mi<sup>2</sup>",
as.character(restaurant.data$NAME), restaurant.data$ratings
) %>% lapply(htmltools::HTML)
map.test <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
map.test
labels <- sprintf(
"<strong>%s</strong><br/><strong> Rating: </strong> <em>%g</em> ",
as.character(restaurant.data$NAME), restaurant.data$ratings
) %>% lapply(htmltools::HTML)
map.test <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
map.test
choropleth <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
counties <-  geojsonio::geojson_read("json/us-counties.json", what = "sp")
counties <-  geojsonio::geojson_read("json/us-counties.json", what = "sp")
restaurant.ratings <- read.csv("data/yelpRatings.csv", stringsAsFactors = FALSE)
View(counties)
choropleth <- leaflet(restaurant.data) %>%
setView(-96, 37.8, 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto")) %>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = NULL,
position = "bottomright")
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto")) %>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = NULL,
position = "bottomright")
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = NULL,
position = "bottomright") %>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = "Ratings",
position = "bottomright") %>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
runApp()
pal <- colorBin(
palette = "7-class Reds",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
?colorBin
?palette
pal <- colorBin(
palette = "Reds",
domain = restaurant.data$ratings, bins = c(3.13, 3.23, 3.43, 3.63, 3.93, 4.03, 4.23))
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = "Ratings",
position = "bottomright") %>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
pal <- colorBin(
palette = "Reds",
domain = restaurant.data$ratings, bins = c(3.13, 3.36, 3.59, 3.82, 4.06))
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = "Ratings",
position = "bottomright") %>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
pal <- colorBin(
palette = "Grays",
domain = restaurant.data$ratings, bins = c(3.13, 3.36, 3.59, 3.82, 4.06))
pal <- colorBin(
palette = "Greys",
domain = restaurant.data$ratings, bins = c(3.13, 3.36, 3.59, 3.82, 4.06))
"<strong>%s</strong><br/><strong> Rating: </strong> <em>%g</em> ",
as.character(restaurant.data$NAME), restaurant.data$ratings) %>%
lapply(htmltools::HTML)
"<strong>%s</strong><br/><strong> Rating: </strong> <em>%g</em> ",
as.character(restaurant.data$NAME), restaurant.data$ratings) %>%
lapply(htmltools::HTML)
"<strong>%s</strong><br/><strong> Rating: </strong> <em>%g</em> ",
as.character(restaurant.data$NAME), restaurant.data$ratings) %>%
lapply(htmltools::HTML)
labels <- sprintf(
"<strong>%s</strong><br/><strong> Rating: </strong> <em>%g</em> ",
as.character(restaurant.data$NAME), restaurant.data$ratings) %>%
lapply(htmltools::HTML)
choropleth <- leaflet(restaurant.data) %>%
setView(lng = -94, lat = 37.45, zoom = 4) %>%
addTiles()%>%
addLegend(pal = pal, values = ~density, opacity = 0.7, title = "Ratings",
position = "bottomright") %>%
addPolygons(fillColor = ~pal(ratings),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
choropleth
>>>>>>> 34004be47b2e2cef216eef550cda6248e49322ed
runApp()
runApp()
runApp()
runApp()
